chap6-1
1. 코드의 재사용성이 높다.
   새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.

2. 코드의 관리가 용이하다.
   코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.

3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
   제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,
   코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

- 객체지향언어의 가장 큰 장점은 코드의 재사용성이 높고 유지보수가 용이하다. 는 것이다.

chap6-2
- 클래스 : 객체를 정의해 놓은 것, 객체의 설계도 , 객체를 생성하는데 사용한다.
- 프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻함

chap6-3
- 객체는 속성과 기능의 집합이다.
- 객체가 가지고 있는 속성과 기능을 그 객체의 멤머라 한다.
- 클래스로부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어 진다.

chap6-4
- 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 한다.
- 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

chap6-5
- 하나의 소스파일에 하나의 클래스만을 정의하는 것이 보통이다.
- 하나의 파일에 둘 이상의 클래스를 정의하는 것도 가능하다.
- 소스 파일의 이름은 public class의 이름과 일치해야 한다.
- 소스 파일 내에 public class가 없다면, 소스파일의 이름은 소스파일 내의 클래스 중 아무거나 정해도 상관없다.


chap6-6
- 클래스로 부터 인스턴스를 생성하는 방법

```
클래스명 변수명;
변수명 = new 클래스명();

Tv t = new Tv();
```

chap6-7
- 같은 클래스로부터 생성되었을지라도 각 인스턴스의 속성은 서로 다른 값을 유지 할 수 있다.

chap6-8
- 객체 배열 안에는 객체의 주소가 저장된다.
- 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열이다.

chap6-9
1. 변수: 하나의 데이터를 저장할 수 있는 공간
2. 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 데이터와 함수의 결합(구조체 + 함수)

chap6-10
- 자바와 같은 객체지향언어에서는 클래스가 사용자 정의 타입이다.

chap6-11
1. 인스턴스 변수 - 클래스 영역에 선언, 인스턴스를 생성할때 만들어짐
    - 인스턴스마다 별도의 저장공간을 가진다.
2. 클래스 변수 - 클래스 변수를 선언하는방법은 인스턴스 변수 앞에 static를 붙이기만 하면 된다.
    - 모든 인스턴스가 공통된 저장공간을 공유 한다.
    - 인스턴스를 생성하지 않고도 언제라도 바로 사용가능 : 클래스이름.클래스변수 형식으로 사용한다.
3. 지역변수 - 메서드 내에 선언, 메서드 내에서만 사용가능
    - for 문등 블럭내에 선언된 지역 변수는 블럭내에서만 사용 가능

chap6-12
- 인스턴스 변수는 인스턴스가 생성될때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든
  인스턴스가 하나의 저장 공간을 공유하므로, 항상 공통된 값을 같는다.

chap6-14
- 메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
- 입력값 또는 출력값이 없을 수도 있다. 입력값 출력값 모두 없을 수도 있다.

chap6-15
- 메서드 선언부는 메서드의 이름과 매개변수 선언, 반환타입 으로 구성되어 있다.
- 메서드의 선언부는 변경사항이 발생하지 않도록 신중히 작성해야한다. 메서드의 선언부를 변경하게 되면, 그메서드가 호출되는 모든 곳이 함께 변경되어야 한다.
- 반환값이 없는 경우 바환타입으로 void를 적어준다.

chap6-16
- 메서드의 선언부 다음에 오는 괄호{}를 메서드의 구현부 라고 하는데, 여기에 메서드를 호출했을때 수행될 문장들을 넣는다.
- 메서드의 반환타입이 void가 아닌 경우. 구현부 {}안에 return 반환값이 반드시 포함되어 있어야 한다.

chap6-17
- 메서드를 호출할때 괄호 안에 지정해준 값들을 인수라고 한다.
- 인수는 메서드가 호출되면 매개변수에 대입되므로, 인수의 타입은 매개변수의 타입과 일치하거나 자동 형변환 가능해야 한다.

chap6-18
- 메서드가 호출되면 지금까지 실행 중이던 메서드는 실행을 잠시 멈추고 호출된 메서드의 문장들이 실행된다. 호출된 메서드의 작업이 모두 끝나면 다시 호출한 메서드로 돌아와
  이후의 문장들을 실행한다.

chap6-20
- 반환값의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야 한다.

chap6-22
- 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.
- 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간 결과 등을 저장하는데 사용된다.
- 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.
- 호출스택의 제일 위에 잇는 메서드가 현재 실행 중인 메서드이다.

chap6-23
- 기본현 매개변수 : 변수의 값을 읽기만 할 수 있다.
- 참조현 매개변수 : 변수의 값을 읽고 변경할 수 있다.

chap6-28
1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 staic를 붙인다.
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static를 붙이는 것을 고려한다.

chap6-29
- 클래스멤버가 인스턴스 멤버를 참조 하는 경우는 인스턴스를 생성해야 한다.
  : 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.

chap6-30
- 한 클래스 내에 같은 이름의 메서드를 여러개 정의하는것을 메서드 오버로딩이라 한다.
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
3. 반환 타입은 관계없다.

chap6-32
- 생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드이다.
1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다.

- new 연산자가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.

chap6-33
- 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 디폴트 생성자를 추가하여 컴파일을 한다.
- 개발자가 클래스에 생성자를 추가 할경우 컴파일러는 기본 생성자를 추가 해주지 않는다.

chap6-36
- 생성자의 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

chap6-37
- this 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
  모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
- this(),this(매개변수) 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.

chap6-39
1. 클래스 변수 초기화 -> 인스턴스 변수 초기화
2. 자동 초기화 -> 명시적 초기화 -> 초기화 블럭, 생성자
3. 클래스 초기화 블럭 : 클래스 변수의 복잡한 초기화에 사용된다.
4. 인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용된다.






















   



